import { Hono } from 'hono'
import { cors } from 'hono/cors'
import type { D1Database } from '@cloudflare/workers-types'
import { createToken, authMiddleware, roleMiddleware } from './auth'
import { aiIntelligence, geminiService } from './ai_services'
import { User } from '@apollo/types'

const app = new Hono<{ Bindings: { DB: D1Database } }>()

app.use('*', cors({
  origin: '*',
  allowMethods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowHeaders: ['Content-Type', 'Authorization'],
  exposeHeaders: ['Content-Length'],
  maxAge: 600,
  credentials: true,
}))

app.get('/', (c) => {
  return c.text('Apollo STEM Academy API')
})

// Compatibility Route for root POST (used by reference index.html)
app.post('/', async (c) => {
  return handleAIGenerate(c);
});

// Authentication Routes
app.post('/auth/google', async (c) => {
  const { token, role } = await c.req.json()

  try {
    // Verify token with Google's tokeninfo endpoint
    // This is a lightweight way to verify tokens in a Worker environment
    const response = await fetch(`https://oauth2.googleapis.com/tokeninfo?id_token=${token}`);

    if (!response.ok) {
      throw new Error('Invalid Google Token');
    }

    const payload = await response.json() as any;

    // Authorization Check (Phase 1)
    let isAuthorized = false;

    // 1. Check Database if available
    if (c.env.DB) {
      try {
        const authRecord = await c.env.DB.prepare('SELECT role FROM authorized_access WHERE email = ?').bind(payload.email).first();
        if (authRecord) isAuthorized = true;
      } catch (e) {
        console.error('Auth table check failed', e);
      }
    }

    // 2. Demo Whitelist Fallback
    const demoWhitelist = [
      'test@example.com',
      'robin@apollo.edu',
      'teacher@apollo.edu',
      'parent@apollo.edu',
      'student@apollo.edu',
      'apolloacademyaiteacher@gmail.com' // Whitelist user's likely email
    ];
    if (demoWhitelist.includes(payload.email)) isAuthorized = true;

    if (!isAuthorized) {
      return c.json({ success: false, error: 'Access Denied: Email not in authorized roster.' }, 403);
    }

    const user: User = {
      id: payload.sub,
      email: payload.email,
      name: payload.name,
      role: role || 'student' // Use the role selected in the frontend
    }

    const jwtToken = await createToken(user)
    return c.json({ token: jwtToken, user })
  } catch (err: any) {
    console.error('Google Auth Error:', err.message);

    // Fallback for development/testing if token is invalid or during local dev
    // WARNING: Remove this for absolute production security
    if (token === 'mock_jwt') {
      const mockUser: User = {
        id: 'mock_123',
        email: 'mock@example.com',
        role: role || 'student',
        name: 'Mock User'
      }
      const jwtToken = await createToken(mockUser)
      return c.json({ token: jwtToken, user: mockUser })
    }

    return c.json({ success: false, error: 'Authentication failed' }, 401)
  }
})

// Protected Routes Example
app.get('/student/dashboard', authMiddleware, roleMiddleware(['student']), (c) => {
  return c.json({ message: 'Welcome to the Student Dashboard' })
})

// AI Intelligence Routes
app.get('/api/reports/:studentId', authMiddleware, roleMiddleware(['teacher', 'volunteer']), async (c) => {
  const studentId = c.req.param('studentId')
  // Accessing GEMINI_API_KEY from environment bindings
  const apiKey = (c.env as any).GEMINI_API_KEY
  const report = await aiIntelligence.generateNarrativeReport(c.env.DB, studentId, apiKey)
  return c.json(report)
})

app.get('/api/student/assignments', authMiddleware, roleMiddleware(['student']), async (c) => {
  const payload = c.get('jwtPayload') as any;
  let assignments: any[] = [];

  if (c.env.DB) {
    try {
      // Fetch assignments for classes the student is enrolled in
      const query = `
        SELECT 
          a.id, a.title, a.description, a.due_date, c.name as subject,
          COALESCE(s.status, 'pending') as status
        FROM assignments a
        JOIN classes c ON a.class_id = c.id
        JOIN enrollments e ON c.id = e.class_id
        LEFT JOIN submissions s ON a.id = s.assignment_id AND s.student_id = ?
        WHERE e.student_id = ?
      `;
      const { results } = await c.env.DB.prepare(query).bind(payload.id, payload.id).all();
      assignments = results;
    } catch (e) {
      console.error('Failed to fetch assignments', e);
    }
  }

  // Fallback / Demo Data if no assignments found (for testing purposes)
  if (assignments.length === 0) {
    assignments = [
      {
        id: 'demo_1',
        title: 'Algebra: Quadratic Basics (Demo)',
        subject: 'Math',
        due_date: 'Tomorrow, 11:59 PM',
        status: 'in-progress',
        description: 'Solve the 5 quadratic equations generated by your AI tutor.'
      },
      {
        id: 'demo_2',
        title: 'Cell Biology Review (Demo)',
        subject: 'Science',
        due_date: 'Jan 18, 2026',
        status: 'pending',
        description: 'Generate a study guide for the upcoming exam on Mitosis.'
      }
    ];
  }

  return c.json(assignments);
});

app.post('/api/assignments/:assignmentId/submit', authMiddleware, async (c) => {
  const assignmentId = c.req.param('assignmentId')
  const { content } = await c.req.json()
  const payload = c.get('jwtPayload') as any

  await c.env.DB.prepare(
    'INSERT INTO submissions (id, assignment_id, student_id, content) VALUES (?, ?, ?, ?)'
  ).bind(crypto.randomUUID(), assignmentId, payload.id, content).run()

  return c.json({ success: true, message: 'Assignment submitted' })
})

app.get('/api/recommendations/:classId', authMiddleware, roleMiddleware(['teacher']), async (c) => {
  const classId = c.req.param('classId')
  const recs = await aiIntelligence.getRecommendedassignments(c.env.DB, classId)
  return c.json(recs)
})

app.get('/api/alerts/stuck', authMiddleware, roleMiddleware(['teacher', 'volunteer']), async (c) => {
  const alerts = await aiIntelligence.checkStuckStudents(c.env.DB)
  return c.json(alerts)
})

app.get('/api/submissions/pending', authMiddleware, roleMiddleware(['teacher']), async (c) => {
  const submissions = await c.env.DB.prepare(
    'SELECT s.*, u.name as student_name FROM submissions s JOIN users u ON s.student_id = u.id WHERE s.grade IS NULL ORDER BY s.created_at DESC'
  ).all();
  return c.json(submissions.results);
})

app.get('/api/parent/child-data', authMiddleware, roleMiddleware(['parent']), async (c) => {
  const payload = c.get('jwtPayload') as any;

  // In a real app, we'd have a parent_student_map table. 
  // For now, we mock finding the "first" student for this parent's email domain or similar.
  const student = await c.env.DB.prepare(
    'SELECT * FROM users WHERE role = "student" LIMIT 1'
  ).first();

  if (!student) return c.json({ error: 'No student found' }, 404);

  const progress = await c.env.DB.prepare(
    'SELECT * FROM progress_logs WHERE student_id = ? ORDER BY created_at DESC LIMIT 5'
  ).bind(student.id).all();

  const assignments = await c.env.DB.prepare(
    'SELECT * FROM assignments WHERE class_id IN (SELECT id FROM classes) LIMIT 5'
  ).all();

  return c.json({
    student,
    recentActivity: progress.results,
    activeAssignments: assignments.results
  });
})

app.get('/api/messages/:chatId', authMiddleware, async (c) => {
  const chatId = c.req.param('chatId')
  const messages = await c.env.DB.prepare(
    'SELECT * FROM messages WHERE class_id = ? OR student_id = ? ORDER BY created_at ASC'
  ).bind(chatId, chatId).all();
  return c.json(messages.results);
})

app.post('/api/messages', authMiddleware, async (c) => {
  const { recipientId, content, role } = await c.req.json()
  const payload = c.get('jwtPayload') as any;

  const id = crypto.randomUUID()
  await c.env.DB.prepare(
    'INSERT INTO messages (id, student_id, content, sender_id, created_at) VALUES (?, ?, ?, ?, ?)'
  ).bind(id, recipientId, content, payload.id, new Date().toISOString()).run();

  return c.json({ success: true, id });
})

app.get('/api/parent/ai-summary', authMiddleware, roleMiddleware(['parent']), async (c) => {
  const apiKey = (c.env as any).GEMINI_API_KEY
  // In a real app, gather student progress data first
  const studentData = "Student showed improvement in Math (85%) but needs more help in Science worksheets."

  const prompt = `Synthesize this student data into a warm, encouraging 3-sentence summary for a parent. Focus on a "growth mindset" tone. Data: ${studentData}`

  // Use a simple fetch to Gemini for now as a lightweight worker pattern
  const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-flash-latest:generateContent?key=${apiKey}`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      contents: [{ parts: [{ text: prompt }] }]
    })
  });

  const genData = await res.json() as any;
  const summary = genData.candidates?.[0]?.content?.parts?.[0]?.text || "Excellent progress this week! Encourage continued exploration of new STEM concepts.";

  return c.json({ summary });
})

// --- Gamified Mastery & AI Learning Paths ---

app.get('/api/student/mastery', authMiddleware, async (c) => {
  const payload = c.get('jwtPayload') as any;
  const mastery = await c.env.DB.prepare(
    'SELECT * FROM student_mastery WHERE student_id = ?'
  ).bind(payload.id).all();

  // If none exists, return mock defaults for UX
  if (mastery.results.length === 0) {
    return c.json([
      { subject: 'math', score: 65, level: 3 },
      { subject: 'science', score: 40, level: 1 },
      { subject: 'language_arts', score: 82, level: 5 }
    ]);
  }

  return c.json(mastery.results);
})

app.get('/api/student/achievements', authMiddleware, async (c) => {
  const payload = c.get('jwtPayload') as any;
  const achievements = await c.env.DB.prepare(
    'SELECT a.*, (ua.earned_at IS NOT NULL) as earned FROM achievements a LEFT JOIN user_achievements ua ON a.id = ua.achievement_id AND ua.user_id = ?'
  ).bind(payload.id).all();

  // Seed if empty
  if (achievements.results.length === 0) {
    const seeds = [
      { id: 'apprentice', name: 'AI Apprentice', desc: 'Used an AI tool for the first time.', icon: 'Sparkles' },
      { id: 'math_whiz', name: 'Math Whiz', desc: 'Completed 5 math-related missions.', icon: 'Star' },
      { id: 'consistent', name: 'Always Active', desc: 'Logged in 3 days in a row.', icon: 'Heart' }
    ];
    for (const s of seeds) {
      await c.env.DB.prepare('INSERT OR IGNORE INTO achievements (id, name, description, icon) VALUES (?, ?, ?, ?)').bind(s.id, s.name, s.desc, s.icon).run();
    }
    return c.json(seeds.map(s => ({ ...s, earned: false })));
  }

  return c.json(achievements.results);
})

app.get('/api/student/recommendations', authMiddleware, async (c) => {
  const payload = c.get('jwtPayload') as any;
  const apiKey = (c.env as any).GEMINI_API_KEY;
  const recs = await aiIntelligence.getStudentRecommendations(c.env.DB, payload.id, apiKey);
  return c.json(recs);
})

app.post('/api/ai/generate-missions', authMiddleware, async (c) => {
  const payload = c.get('jwtPayload') as any;
  const apiKey = (c.env as any).GEMINI_API_KEY;

  try {
    // 1. Fetch student data for personalization
    const mastery = await c.env.DB.prepare(
      'SELECT subject, score, level FROM student_mastery WHERE student_id = ?'
    ).bind(payload.id).all();

    const studentContext = mastery.results.length > 0
      ? JSON.stringify(mastery.results)
      : "New student with no prior data. Focus on foundational STEM concepts.";

    // 2. Call Gemini to generate 3 missions
    const prompt = `Based on this student's mastery data: ${studentContext}, generate 3 short, engaging "Learning Missions" (each 3-5 words). Return them as a simple comma-separated string.`;

    const systemPrompt = "You are the Apollo Academy AI Coordinator. You create personalized, high-impact learning trajectories for STEM students.";

    let answer = "Master Linear Equations, Explore Cell Structures, Building Your First App"; // Fallback

    if (apiKey) {
      try {
        const aiResponse = await geminiService.generate(apiKey, prompt, systemPrompt);
        if (aiResponse) answer = aiResponse;
      } catch (e) {
        console.error("Mission generation failed, using fallbacks");
      }
    }

    const missions = answer.split(',').map(m => m.trim()).slice(0, 3);

    // 3. Log the activity
    if (c.env.DB) {
      await c.env.DB.prepare(
        'INSERT INTO progress_logs (id, student_id, tool_id, activity_type, performance_score, metadata) VALUES (?, ?, ?, ?, ?, ?)'
      ).bind(
        crypto.randomUUID(),
        payload.id,
        'ai_hub',
        'GENERATE_MISSIONS',
        100,
        JSON.stringify({ missions })
      ).run();
    }

    return c.json({ success: true, missions });
  } catch (err: any) {
    return c.json({ success: false, error: err.message }, 500);
  }
})

async function checkAchievements(db: D1Database, userId: string) {
  // Simple logic: If user has > 1 progress log, give them 'apprentice'
  const count = await db.prepare('SELECT COUNT(*) as c FROM progress_logs WHERE student_id = ?').bind(userId).first() as any;
  if (count.c >= 1) {
    await db.prepare('INSERT OR IGNORE INTO user_achievements (user_id, achievement_id) VALUES (?, ?)').bind(userId, 'apprentice').run();
  }
}

app.get('/teacher/dashboard', authMiddleware, roleMiddleware(['teacher']), (c) => {
  return c.json({ message: 'Welcome to the Teacher Dashboard' })
})

// Shared AI Generation Logic
async function handleAIGenerate(c: any) {
  const body = await c.req.json();
  const prompt = body.prompt;
  const toolKey = body.toolKey || 'math_solver'; // Default for simple prompts
  const payload = c.get('jwtPayload') as any;
  const apiKey = (c.env as any).GEMINI_API_KEY;

  try {
    let answer = "";

    // Realistic STEM Fallbacks for Demo Mode
    const fallbacks: Record<string, string> = {
      math_solver: "Calculated Solution:\n\n1. Identify Variables: We define the knowns and unknowns based on your input.\n2. Strategy: Apply the relevant mathematical properties (e.g., Distributive, Associative).\n3. Step-by-Step: Perform calculations with precision, ensuring each transformation is valid.\n4. Verification: Substitute the result back into the original expression to confirm accuracy.\n\n[Apollo STEM Academy: AI-Powered Learning Support]",
      worksheet_gen: "Apollo STEM Worksheet - Topic: Research Focus\n\nPart I: Targeted Practice\n- Concept Review: Foundational principles tailored to the selected grade.\n- Problem Set: 5 customized challenges designed to build mastery.\n\nPart II: Solution Key\n- Detailed explanations for each problem to reinforce the learning loop.\n\n[Apollo STEM Academy: Mission-Ready Curriculum]",
      science_lab: "Lab Protocol & Insight:\n\n- Scientific Context: Understanding the underlying physics/chemistry of the concept.\n- Experimental Design: Safe, effective steps to observe the phenomenon in action.\n- Data Analysis: What to look for and how to interpret your findings.\n\n[Apollo STEM Academy: Future-Ready Science Support]",
      study_guide: "Strategic Study Guide:\n\n- Essential Themes: The 'big ideas' you need to master for success.\n- Key Glossary: Definitions of critical terminology.\n- Retention Plan: Active recall questions and memorization techniques.\n\n[Apollo STEM Academy: Personalized Mastery Guide]"
    };

    answer = fallbacks[toolKey] || `Helpful response generated for ${toolKey}. Please describe your STEM project in more detail for a deeper analysis.`;

    if (apiKey) {
      try {
        const systemPrompt = "You are an expert STEM tutor at Apollo Academy. Provide a helpful, encouraging, and accurate answer to the student. CRITICAL: Do not use LaTeX formatting. Do not use dollar signs ($) for math. Use plain, readable text only.";
        const realAnswer = await geminiService.generate(apiKey, prompt, systemPrompt);
        if (realAnswer) answer = realAnswer;
      } catch (e: any) {
        console.error("Gemini Generation Failed Info:", { error: e.message, keyPrefix: apiKey.substring(0, 5) });
        // Fall back remains in 'answer'
      }
    } else {
      console.warn("GEMINI_API_KEY is missing from environment");
    }
    if (c.env.DB) {
      try {
        await c.env.DB.prepare(
          'INSERT INTO progress_logs (id, student_id, tool_id, activity_type, performance_score, metadata) VALUES (?, ?, ?, ?, ?, ?)'
        ).bind(
          crypto.randomUUID(),
          payload?.id || 'anonymous_user',
          toolKey,
          `AI_TOOL_${toolKey.toUpperCase()}`,
          85,
          JSON.stringify({ prompt, answer, source: 'ai_tool_endpoint' })
        ).run();
      } catch (dbError) {
        // Logging is secondary to functionality
      }
    }

    return c.json({ success: true, answer });
  } catch (err: any) {
    return c.json({ success: false, error: err.message }, 500);
  }
}

// Centralized AI Tool Endpoint
app.post('/api/ai/generate', async (c) => {
  return handleAIGenerate(c);
});


// --- Google Classroom Integration (Phase 4) ---

app.post('/api/google/sync', authMiddleware, async (c) => {
  // Mock synchronization logic
  // In a real app, this would use the Google Classroom API with the user's OAuth token
  return c.json({
    success: true,
    message: "Successfully synchronized with Google Classroom.",
    synced_students: 5,
    synced_assignments: 3,
    timestamp: new Date().toISOString()
  });
});

export default app;
